--@name secret door
--@author Nakkitsunami
--@shared
--@include nakilibs/screen_shatter_obj.txt

if SERVER then
    hook.add("Net", "", function(name, len, ply)
        if name == "feedback_to_server" then
            net.start("feedback_to_client")
            net.writeString(net.readString())
            net.send(owner(),false)
        end
        if name == "state_to_server" then
            net.start("state_to_client")
            net.writeBool(net.readBool())
            net.send(find.allPlayers(),false)
        end
    end)
else
    
    require("nakilibs/screen_shatter_obj.txt")
    
    cf = cf or {}
    cf.created = {}
    
    function capture_texture(texname, filter, pos, ang, size)
        if texname == "" or not texname then return end
        
        local rtName = texname.."_capture"
        render.createRenderTarget(rtName)
        
        local temp = material.create("VertexLitGeneric")
        temp:setTextureRenderTarget("$basetexture", rtName)
        
        hook.add("renderscene", "capture_view_ortho", function(origin, angles)
            render.selectRenderTarget(rtName)
            render.clear(Color(0,0,0))
            
            for k, v in pairs(filter) do
                v:setNoDraw(true)
            end
            size = size / 2
            
            render.renderView({
                w = 1024,
                h = 1024,
                origin = pos - ang:getForward() * size,
                angles = ang,
                aspect = 1,
                drawviewmodel = false,
                drawviewer = false,
                znear = size - 5,
                zfar = size + 10,
                fov = 90
            })
            render.selectRenderTarget()
            for k, v in pairs(filter) do
                v:setNoDraw(false)
            end
            
            hook.remove("renderscene","capture_view_ortho")
        end)
        
        cf.created[texname] = temp
        return temp
    end
    
    local models_ready = false
    
    local obj_data = unholy_obj_table
    
    local pos_data = {
        ["mesh.001"] = {-0.171805,-0.407767},
        ["mesh.002"] = {-0.954938,0.971595},
        ["mesh.003"] = {-1.739233,0.940437},
        ["mesh.004"] = {-0.570632,0.909736},
        ["mesh.005"] = {-1.303436,0.936276},
        ["mesh.006"] = {-0.203379,0.843699},
        ["mesh.007"] = {0.150101,0.922609},
        ["mesh.008"] = {0.533610,0.987833},
        ["mesh.009"] = {0.937146,0.936842},
        ["mesh.010"] = {1.359607,0.888593},
        ["mesh.011"] = {1.682766,0.933334},
        ["mesh.012"] = {1.673605,0.613381},
        ["mesh.013"] = {1.077947,0.558271},
        ["mesh.014"] = {0.322611,0.598012},
        ["mesh.015"] = {1.347392,0.667702},
        ["mesh.016"] = {0.791771,0.686995},
        ["mesh.017"] = {-0.155528,0.525079},
        ["mesh.018"] = {-0.630666,0.646415},
        ["mesh.019"] = {-0.329203,0.637133},
        ["mesh.020"] = {-1.293827,0.578981},
        ["mesh.021"] = {-0.891584,0.561629},
        ["mesh.022"] = {-1.776366,0.292720},
        ["mesh.023"] = {-1.727507,0.581406},
        ["mesh.024"] = {-1.776366,0.035577},
        ["mesh.025"] = {-1.577972,-0.095224},
        ["mesh.026"] = {-1.334629,0.062668},
        ["mesh.027"] = {-1.279845,0.298641},
        ["mesh.028"] = {-0.973303,0.365069},
        ["mesh.029"] = {-0.834984,0.178854},
        ["mesh.030"] = {-1.086766,-0.053953},
        ["mesh.031"] = {-1.026764,-0.271864},
        ["mesh.032"] = {-1.286206,-0.393728},
        ["mesh.033"] = {-1.589551,-0.333709},
        ["mesh.034"] = {-1.787945,-0.511478},
        ["mesh.035"] = {-1.414104,-0.611575},
        ["mesh.036"] = {-1.792000,-0.977143},
        ["mesh.037"] = {-1.552872,-0.861078},
        ["mesh.038"] = {-1.296872,-0.963935},
        ["mesh.039"] = {-0.924891,-0.912171},
        ["mesh.040"] = {-0.576316,-0.972293},
        ["mesh.041"] = {-0.320316,-0.972293},
        ["mesh.042"] = {0.405252,-0.971583},
        ["mesh.043"] = {0.913915,-0.928279},
        ["mesh.044"] = {1.692793,-0.874937},
        ["mesh.045"] = {1.342359,-0.866990},
        ["mesh.046"] = {1.613917,-0.602581},
        ["mesh.047"] = {1.339219,-0.662988},
        ["mesh.048"] = {0.958308,-0.622744},
        ["mesh.049"] = {0.484549,-0.607074},
        ["mesh.050"] = {-0.227853,-0.723774},
        ["mesh.051"] = {0.230219,-0.810452},
        ["mesh.052"] = {-0.929843,-0.659104},
        ["mesh.053"] = {-0.657426,-0.569039},
        ["mesh.054"] = {-0.713613,-0.346361},
        ["mesh.055"] = {-0.437275,-0.238512},
        ["mesh.056"] = {0.063390,-0.297924},
        ["mesh.057"] = {0.378037,-0.399519},
        ["mesh.058"] = {0.617933,-0.200835},
        ["mesh.059"] = {0.907694,-0.214764},
        ["mesh.060"] = {1.095692,-0.370577},
        ["mesh.061"] = {1.351339,-0.270296},
        ["mesh.062"] = {1.676129,-0.352112},
        ["mesh.063"] = {1.789978,-0.056341},
        ["mesh.064"] = {1.447758,-0.009176},
        ["mesh.065"] = {1.037228,-0.007509},
        ["mesh.066"] = {1.715785,0.344824},
        ["mesh.067"] = {1.459650,0.241171},
        ["mesh.068"] = {0.992066,0.260572},
        ["mesh.069"] = {0.628215,0.212692},
        ["mesh.070"] = {0.419122,0.342209},
        ["mesh.071"] = {0.488712,0.010792},
        ["mesh.072"] = {0.137539,0.001348},
        ["mesh.073"] = {0.184733,0.230184},
        ["mesh.074"] = {-0.197342,0.293773},
        ["mesh.075"] = {-0.181386,0.053905},
        ["mesh.076"] = {-0.441742,-0.021557},
        ["mesh.077"] = {-0.571249,0.186904}
    }
    
    local ct2 = 0
    local anim_done = true
    local drop = false
    
    local ct = 0
    
    
    local screen_ent = chip():getLinkedComponents()[1]
    
    if not screen_ent then return end
    
    local area_size = screen_ent:obbSize().y
    
    local edges = hologram.create(screen_ent:localToWorld(Vector(0,0,1.5)), screen_ent:localToWorldAngles(Angle(0,-90,0)), "models/props_phx/construct/metal_tube.mdl", Vector(area_size*1.22,area_size*1.22,0.01)/48)
    edges:setNoDraw(true)
    edges:suppressEngineLighting(true)
    edges:setFilterMag(TEXFILTER.ANISOTROPIC)
    edges:setFilterMin(TEXFILTER.LINEAR)
    
    timer.simple(0.1,function()
        local capture_mat_edges = capture_texture("edges", {chip(),screen_ent}, screen_ent:localToWorld(Vector(0.05,0.0)), screen_ent:localToWorldAngles(Angle(90,0,0)), area_size*1.24)
        edges:setMaterial("!"..capture_mat_edges:getName())
    end)
    
    local capture_mat = capture_texture("center", {chip(),screen_ent}, screen_ent:localToWorld(Vector(-0.05,0.0)), screen_ent:localToWorldAngles(Angle(90,0,0)), area_size*1.02)
    
    local new_index = 0
    local holos = {}
    
    hook.add("Net", "", function(name, len, ply)
        
        if player() == owner() then
            if name == "feedback_to_client" then
                print(net.readString())
            end
        else
            if name == "state_to_client" then
                drop = net.readBool()
                anim_done = false
                ct = timer.curtime()
                
                if screen_ent then
                    timer.simple(drop and 0 or 0.5,function()
                        screen_ent:emitSound("ambient/materials/rock5.wav", 80, 100, 2, CHANNEL_AUTO)
                    end)
                end
            end
        end
    end)
    
    function create_mesh()
        local w, h = 1920/1080, 1080/1080
        local size = area_size/95.4*24.5
        if obj_data and obj_data != nil then
            obj = mesh.createFromObj(obj_data)
            hook.add("think","obj_parse",function()
                if obj and obj != nil then
                    for index, data in pairs(obj) do
                        new_index = new_index + 1
                        local holo_pos = Vector(pos_data[string.sub(index,1,8)][2],pos_data[string.sub(index,1,8)][1],1.5)*Vector(w*size,h*size,1)
                        holos[new_index] = hologram.create(screen_ent:localToWorld(holo_pos),screen_ent:localToWorldAngles(Angle(0,90,-90)),"models/hunter/blocks/cube025x025x025.mdl",Vector(h*size,1,w*size))
                        holos[new_index]:setMesh(obj[index])
                        holos[new_index]:setMaterial("!"..capture_mat:getName())
                        holos[new_index]:suppressEngineLighting(true)
                        holos[new_index]:setNoDraw(true)
                        holos[new_index]:setFilterMag(TEXFILTER.ANISOTROPIC)
                        holos[new_index]:setFilterMin(TEXFILTER.LINEAR)
                        
                        holos[new_index].pos = holo_pos
                        holos[new_index].ang = Angle(0,90,-90)
                        
                        holos[new_index].done = false
                    end
                    hook.remove("think","obj_parse")
                    models_ready = true
                    
                    --[[
                    if player() == findply then
                        net.start("feedback_to_server")
                        net.writeString(player():getName().." finished loading!")
                        net.send()
                    end]]
                    table.sort(holos, function(a, b)
                        local apos = a.pos
                        local bpos = b.pos
                        return apos:getLength() < bpos:getLength()
                    end)
                end
            end)
            
        end
    end
    
    create_mesh()
    
    local drop = false
    
    local anim_length = 1/0.8
    
    hook.add("Render","",function()
        render.clear(Color(0,0,0,0))
        if not models_ready then return end
        if player() == owner() then
            if owner():keyDown(IN_KEY.RELOAD) then
                if toggle_down != true and anim_done == true then
                    toggle_down = true
                    drop = not drop
                    
                    
                    timer.simple(drop and 0 or 0.5,function()
                        screen_ent:emitSound("ambient/materials/rock5.wav", 80, 100, 2, CHANNEL_AUTO)
                    end)
                    
                    net.start("state_to_server")
                    net.writeBool(drop)
                    net.send()
                    anim_done = false
                    ct = timer.curtime()
                end
            else
                toggle_down = false
            end
        end
        if cpuAverage() < cpuMax()*0.75 then
            if drop then
                for k = 1, #holos do
                    local v = holos[k]
                    if not anim_done then
                        if k < #holos - 25 then
                            local time = math.easeInSine(math.clamp(((timer.curtime()-ct)*1-3/anim_length*k/#holos)*anim_length,0,1.1))--math.clamp(0.95-1.5*k/#holos,0,1)--
                            
                            if time < 1 then
                                if v.done != true then
                                    v.done = true
                                end
                                local time_2 = time
                                local ease = math.clamp(math.easeInSine(time_2),0,1)
                                local ease_alt = 1-ease
                                v:setColor(Color(255*ease_alt,255*ease_alt,255*ease_alt,255))
                                
                                v:setPos(screen_ent:localToWorld(v.pos+Vector(0,0,-100*area_size/95)*time_2))
                                
                                v:setAngles(screen_ent:localToWorldAngles(v.ang:rotateAroundAxis(v.pos:getAngle():getRight(),70*ease)))
                            else
                                if v.done != false then
                                    v.done = false
                                    v:setColor(Color(0,0,0,0))
                                    
                                    if k == #holos-26 then
                                        anim_done = true
                                    end
                                end
                            end
                        end
                    end
                end
            else
                for k = 1, #holos do
                    local v = holos[#holos+1-k]
                    
                    if not anim_done then
                        if k > 26 then
                            local time = math.easeInSine(math.clamp(((timer.curtime()-ct)*1-3/anim_length*k/#holos)*anim_length,0,1.1))--math.clamp(0.95-1.5*k/#holos,0,1)--
                            
                            if time < 1 then
                                if v.done != true then
                                    v.done = true
                                end
                                local time_2 = 1-time
                                local ease = math.clamp(math.easeInSine(time_2),0,1)
                                local ease_alt = 1-ease
                                v:setColor(Color(255*ease_alt,255*ease_alt,255*ease_alt,255))
                                
                                v:setPos(screen_ent:localToWorld(v.pos+Vector(0,0,-100*area_size/95)*time_2))
                                
                                v:setAngles(screen_ent:localToWorldAngles(v.ang:rotateAroundAxis(v.pos:getAngle():getRight(),70*ease)))
                            else
                                if v.done != false then
                                    v.done = false
                                    v:setColor(Color(255,255,255,255))
                                    v:setPos(screen_ent:localToWorld(v.pos))
                                    v:setAngles(screen_ent:localToWorldAngles(v.ang))
                                    if k == 77 then
                                        anim_done = true
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
        for k = 1, #holos do
            local v = holos[k]--holos[#holos+1-k]
            v:draw()
        end
        edges:draw()
    end)
end
