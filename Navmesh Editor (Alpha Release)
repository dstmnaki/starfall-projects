--@name Nakilibs/Navmesh/Navmesh_Editor
--@author Nakkitsunami
--@shared

--[[

            Evening, here's my latest project, a starfall navmesh editor intented for starfall nextbots
            
            
            
            Should be light weight, altho limited to 40 nav areas due to starfall limits
            
            !Note sometimes you may hit navmeshes that are locked, i haven't found a way to fix this
            if it causes your chip to error, it is only on server side, you can still save!
            
            
            Controls:
            
            
            Alt         -------- Unlock controls (Allows you to use mouse wheel, also prevents you from using the editor)
            
            Mouse wheel -------- Tool selection
            Mouse1      -------- Create nav area (Create tool, drag and let go somewhere)
            Mouse1      -------- Corner adjust (Create tool, after placing second point, look at a corner and hold)
            Mouse1      -------- Select nav area (Selection tool/Connect tool)
            Enter       -------- Confirm area (Create tool)
            Enter       -------- Create connection (Connect tool)
            R           -------- Delete area (Area selection tool)
            R           -------- Swap selection mode (Connect tool)
            
            
            Tools:
            
            Create tool    ----- Used to create nav areas
            Connect tool   ----- Connects 2 selected nav areas
            Selection tool ----- Used to view, edit and remove nav areas (removing is the only feature currently)
            
            Load --------------- Loads file from 'data/sf_filedata/nakilibs/navmesh/areas/<map_name>.txt'
            Save --------------- Saves file to 'data/sf_filedata/nakilibs/navmesh/areas/<map_name>.txt'

]]

if SERVER then
    local areasData = {}
    local pendingMapData = {}
    local lookupTableIDS = {}
    
    local hasNavmesh = navmesh.getAllNavAreas()
    
    if hasNavmesh and #hasNavmesh > 0 then
        print("This map has navmesh already!")
    end 
    
    local function sendCreateAreaCallback(success, id, lf, rf, lb, rb, token)
        net.start("createAreaCallback")
        net.writeBool(success)
        net.writeFloat(token or 0)
        if success then
            net.writeFloat(id)
            net.writeVector(lf)
            net.writeVector(rf)
            net.writeVector(lb)
            net.writeVector(rb)
        end
        net.send(owner())
    end

    function createArea(from, to, token, originalID)
        local a = navmesh.createNavArea(from + Vector(0,0,25), to + Vector(0,0,25))
        if not a then
            sendCreateAreaCallback(false, 0, Vector(), Vector(), Vector(), Vector(), token)
            return nil
        end
    
        a:placeOnGround(NAV_CORNER.NUM_CORNERS)
        local id = a:getID()
        local lf = a:getCorner(NAV_CORNER.NORTH_WEST)
        local rf = a:getCorner(NAV_CORNER.NORTH_EAST)
        local lb = a:getCorner(NAV_CORNER.SOUTH_WEST)
        local rb = a:getCorner(NAV_CORNER.SOUTH_EAST)
    
        areasData[id] = {
            lf = lf, rf = rf, lb = lb, rb = rb,
            connections = areasData[id] and areasData[id].connections or {}
        }
    
        sendCreateAreaCallback(true, id, lf, rf, lb, rb, token)
    
        if originalID then
            lookupTableIDS[tostring(originalID)] = id
        end
    
        return a
    end
    
    local function sendConnectCallback(id1, id2)
        net.start("connectAreaCallback")
        net.writeFloat(id1)
        net.writeFloat(id2)
        net.send(owner())
    end
    
    function connectAreas(id1, id2, oneway)
        if not isnumber(id1) or not isnumber(id2) then return false, "Invalid IDs" end
        if not areasData[id1] or not areasData[id2] then return false, "Areas do not exist" end
    
        local first = navmesh.getNavAreaByID(id1)
        local second = navmesh.getNavAreaByID(id2)
    
        areasData[id1].connections = areasData[id1].connections or {}
        areasData[id2].connections = areasData[id2].connections or {}
    
        if not table.hasValue(areasData[id1].connections, id2) then
            table.insert(areasData[id1].connections, id2)
        end
        if not oneway and not table.hasValue(areasData[id2].connections, id1) then
            table.insert(areasData[id2].connections, id1)
        end
    
        if first and first != nil and first:isValid() and second and second != nil and second:isValid() then
            if type(first) != "NavArea" then
                print("Error: First area is not a nav area!")
                return
            end
            if type(second) != "NavArea" then
                print("Error: Second area is not a nav area!")
                return
            end
            first:connectTo(second)
            if not oneway then second:connectTo(first) end
        end
    
        sendConnectCallback(id1, id2)
        return true
    end
    
    function buildConnections(data)
        local conn_ct = 0
        local step = 1
        local ids = table.getKeys(data)
    
        hook.add("Think","build_connections",function()
            if timer.curtime() - conn_ct > 0.05 then
                local id = ids[step]
                if not id then
                    hook.remove("Think","build_connections")
                    net.start("mapBuildComplete")
                    net.send(owner())
                    return
                end
    
                local area = data[id]
                local id_this = lookupTableIDS[tostring(area.id)]
    
                for _, conn in ipairs(area.connections or {}) do
                    local id_that = lookupTableIDS[tostring(conn)]
                    if id_that then
                        local success, reason = connectAreas(id_this, id_that, true)
                        if not success then
                            print("Failed to connect areas: "..reason)
                        end
                    end
                end
    
                conn_ct = timer.curtime()
                step = step + 1
            end
        end)
    end

    function buildMap(data)
        local build_map_ct = 0
        local build_map_iteration = 1
        local max = table.count(data)
    
        hook.add("Think","build_map",function()
            if timer.curtime() - build_map_ct > 0.1 then
                local token = build_map_iteration
                local area = data[token]
                if area then
                    createArea(area.from, area.to, area.id, area.id)
                end
                build_map_ct = timer.curtime()
                build_map_iteration = build_map_iteration + 1
                if build_map_iteration > max then
                    hook.remove("Think","build_map")
                    buildConnections(data)
                end
            end
        end)
    end
    
    hook.add("net", "navmesh_server_handler", function(name, len, ply)
        if name == "sendArea" then
            local token = net.readFloat()
            local from = net.readVector()
            local to = net.readVector()
            createArea(from, to, token)

        elseif name == "connectAreas" then
            local id1 = net.readFloat()
            local id2 = net.readFloat()
            local success, reason = connectAreas(id1, id2)
            if success then
                sendConnectCallback(id1, id2)
            else
                print("Failed to connect areas: "..reason)
            end
        elseif name == "nearestArea" then
            local findNearMe = net.readVector()
            local found = navmesh.getNavArea(findNearMe, 250)
            net.start("sendNearestToOwner")
            if found then
                net.writeBool(true)
                net.writeFloat(found:getID())
            else
                net.writeBool(false)
                net.writeFloat(-1)
            end
            net.send(owner())
        elseif name == "mapChunk" then
            local id = net.readUInt(16)
            local from = net.readVector()
            local to = net.readVector()
            local connStr = net.readString()
            local connections = {}
        
            if connStr ~= "" then
                for _, c in ipairs(string.explode(",", connStr)) do
                    connections[#connections+1] = tonumber(c)
                end
            end
        
            pendingMapData[#pendingMapData+1] = {id = id, from = from, to = to, connections = connections}
        elseif name == "mapUploadComplete" then
            buildMap(pendingMapData)
        elseif name == "removeArea" then
            local id = net.readFloat()
            local a = navmesh.getNavAreaByID(id)
            net.start("removeAreaCallback")
            if a and a != nil and a:isValid() and type(a) == "NavArea" then
                a:remove()
                net.writeFloat(id)
            else
                if type(a) != "NavArea" then
                    print("Error: Selected area is not a nav area!")
                end
                net.writeFloat(0)
            end
            net.send(owner())
        end

    end)

else -- CLIENT
    if player() ~= owner() then return end
    enableHud(owner(), true)
    local check_file_path = file.exists("nakilibs/navmesh/areas/default.txt")
    
    if not check_file_path then
        file.createDir("nakilibs/navmesh/areas/")
        local writeData = {}
        table.insert(writeData,"areaid:<number> - Area ID")
        table.insert(writeData,"x1 y1 z1 x2 y2 z2 - Coordinates (From, To)")
        table.insert(writeData,"<number>,<number>,<number>... - Connections (Number represents an ID of another area)")
        table.insert(writeData,"areaid:1")
        table.insert(writeData,"2 3 4 5 6 7 8")
        table.insert(writeData,"9,10,11,12")
        
        local writeData = table.concat(writeData, "\n")
        file.write("nakilibs/navmesh/areas/default.txt", writeData)
        print("Folder structure created [data/sf_filedata/nakilibs/navmesh/areas/]")
    end
    
    local lookupTable = {}
    
    local mapname = game.getMap()
    local pendingCreates = {}
    local createTokenCounter = 0
    local savedCreateData = {}
    
    local navArea = {}
    
    local M1 = { Down = true }
    local R = { Down = false }
    local Enter = { Down = false }
    
    local initiate = false
    
    local tools = {
        [1] = "Create New Area",
        [2] = "Connect 2 Areas",
        [3] = "Select Area",
        [8] = "Load File",
        [9] = "Save File"
    }

    local selection = 1
    local selectCT = 0
    local controlsOK = false
    local controlsOKChanged = false
    local controlsOKCT = 0
    
    local stillReading = false
    
    local temp = {}
    local targetWeapon = "none"
    local findWeapon = owner():getWeapon(targetWeapon)
    if findWeapon and findWeapon != nil and findWeapon:isValid() then
        input.selectWeapon(findWeapon)
    else
        print("Weapon \"none\" not found, select it to proceed..")
    end
    
    function getNearestArea(target)
        net.start("nearestArea")
        net.writeVector(target)
        net.send()
    end
    
    function saveMap()
        local lines = {}
        for id, create in pairs(savedCreateData) do
            if create and create.from and create.to then
                lines[#lines+1] = "areaid:"..id
                lines[#lines+1] = string.format(
                    "%f %f %f %f %f %f",
                    create.from.x, create.from.y, create.from.z,
                    create.to.x, create.to.y, create.to.z
                )
                lines[#lines+1] = create.connections and #create.connections > 0 and table.concat(create.connections, ",") or ""
            end
        end
        file.write("nakilibs/navmesh/areas/"..mapname..".txt", table.concat(lines,"\n"))
        print("File saved as "..mapname)
    end
    
    local function loadMap()
        if stillReading then print("Already loading a file, please wait...") return end
        local path = "nakilibs/navmesh/areas/"..(mapname or game.getMap())..".txt"
        local contents = file.read(path)
        if not contents or contents == "" then return print("No file was locationed with the name "..mapname..".txt in folder data/sf_filedata/nakilibs/navmesh/areas/ !") end
        print("File found! Unpacking and sending to server, please wait...")
        stillReading = true
        navAreas = {}
        savedCreateData = {}
        pendingCreates = {}
        local lines = string.explode("\n", contents)
        local id, from, to, connections
        local step = 0
        local load_map_chunks_ct = 0
        local line_step = 1
        local sent = false
        hook.add("Think", "load_map_chunks", function()
            if timer.curtime() - load_map_chunks_ct > 0.1 then
                local line = lines[line_step]
        
                if line_step > #lines then
                    net.start("mapUploadComplete")
                    net.send()
                    hook.remove("Think", "load_map_chunks")
                    print("All data sent to server successfully!")
                    print("Loading "..(#lines/3).." areas...")
                    return
                end
        
                if line then
                    line = string.trim(line)
        
                    if string.startsWith(line, "areaid:") then
                        id = tonumber(string.sub(line, 8))
                        from, to, connections = nil, nil, nil
                        step = 1
                        line_step = line_step + 1
        
                    elseif step == 1 then
                        local nums = string.explode(" ", line)
                        if #nums >= 6 then
                            from = Vector(tonumber(nums[1]), tonumber(nums[2]), tonumber(nums[3]))
                            to   = Vector(tonumber(nums[4]), tonumber(nums[5]), tonumber(nums[6]))
                            step = 2
                            line_step = line_step + 1
                        else
                            line_step = line_step + 1
                        end
        
                    elseif step == 2 then
                        if line ~= "" then
                            connections = line
                        else
                            connections = ""
                        end
                        if connections == "nil" then connections = "" end
                        if id and from and to then
                            net.start("mapChunk")
                            net.writeUInt(id, 16)
                            net.writeVector(from)
                            net.writeVector(to)
                            net.writeString(connections or "")
                            net.send()
                            if connections ~= "" then
                                connections = string.explode(",",connections)
                            else
                                connections = {}
                            end
                            pendingCreates[id] = { from = from, to = to, connections = connections}
                        end
        
                        step = 0
                        line_step = line_step + 1
                    else
                        line_step = line_step + 1
                    end
                else
                    line_step = line_step + 1
                end
        
                load_map_chunks_ct = timer.curtime()
            end
        end)
    end


    hook.add("HUDShouldDraw", "navmesh_hud_should_draw", function(str)
        if owner():getActiveWeapon():getClass() ~= targetWeapon then return true end
        if str == "CHudCrosshair" then return false end
        if str == "CHudWeaponSelection" then
            if not input.isKeyDown(KEY.LALT) and owner():isTyping() == false then
                return false
            else
                return true
            end
        end
    end)

    hook.add("MouseWheeled","navmesh_wheel",function(delta)
        if (timer.curtime() - selectCT) < 0.05 or input.isKeyDown(KEY.LALT) or not controlsOK then return end
        if delta < 0 then
            selection = selection + 1
        elseif delta > 0 then
            selection = selection - 1
        end
        if selection < 1 then selection = 9 elseif selection > 9 then selection = 1 end
        while not tools[selection] do
            selection = (delta < 0) and (selection + 1) or (selection - 1)
            if selection < 1 then selection = 9 elseif selection > 9 then selection = 1 end
        end
        selectCT = timer.curtime()
        temp = {}
        if selection == 2 then
            temp.selectedFirst = true
        end
    end)

    local nearestDist = 1e18
    local function updateNearestCorner()
        if not (temp.left_front and temp.right_front and temp.left_back and temp.right_back) then return end
        local tr = owner():getEyeTrace().HitPos
        nearestDist = 1e18
        local best
        local d
        d = temp.left_front:getDistance(tr); if d < nearestDist then nearestDist = d; best = 1 end
        d = temp.right_front:getDistance(tr); if d < nearestDist then nearestDist = d; best = 2 end
        d = temp.left_back:getDistance(tr);  if d < nearestDist then nearestDist = d; best = 3 end
        d = temp.right_back:getDistance(tr); if d < nearestDist then nearestDist = d; best = 4 end
        temp.cornerSelected = best
    end

    hook.add("think","navmesh_think",function()
        controlsOK = (owner():isTyping() == false and owner():getActiveWeapon():getClass() == targetWeapon)
        if controlsOK then
            if not controlsOKChanged then
                controlsOKChanged = true
                controlsOKCT = timer.curtime()
                selectCT = timer.curtime()
            end
        else
            controlsOKChanged = false
        end
        
        local realM1 = input.isMouseDown(MOUSE.MOUSE1)
        
        if not realM1 and not initiate and (timer.curtime() - chip():getCreationTime()) > 0.1 then
            initiate = true
        end
        
        M1.Pressed = realM1 and controlsOK and not input.isKeyDown(KEY.LALT) and initiate
        R.Pressed = input.isKeyDown(KEY.R) and controlsOK and not input.isKeyDown(KEY.LALT) and initiate
        Enter.Pressed = input.isKeyDown(KEY.ENTER) and controlsOK and not input.isKeyDown(KEY.LALT) and initiate
        
        if Enter["Pressed"] then
            if Enter["Down"] != true then
                Enter["Down"] = true
                if selection == 1 then
                    if temp.secondPlaced then
                        local origFrom = temp.firstPlaced
                        local origTo = temp.secondPlaced
                        
                        createTokenCounter = createTokenCounter + 1
                        local token = createTokenCounter
                        pendingCreates[token] = { from = origFrom, to = origTo, connections = {} }
                        net.start("sendArea")
                        net.writeFloat(token)
                        net.writeVector(origFrom)
                        net.writeVector(origTo)
                        net.send()
                        
                        temp = {}
                    end
                elseif selection == 2 then
                    if temp.selectedFirstID and temp.selectedSecondID then
                        net.start("connectAreas")
                        net.writeFloat(temp.selectedFirstID)
                        net.writeFloat(temp.selectedSecondID)
                        net.send()
                        
                        temp = {}
                        temp.selectedFirst = true
                    elseif temp.selectedFirstID or temp.selectedSecondID then
                        print("Only 1 Area Selected!")
                    else
                        print("No Areas Selected!")
                    end
                elseif selection == 8 then
                    loadMap()
                elseif selection == 9 then
                    saveMap()
                end
            end
        else
            if Enter["Down"] != false then
                Enter["Down"] = false
            end
        end
        
        if R["Pressed"] then
            if R["Down"] != true then
                R["Down"] = true
                if selection == 2 then
                    temp.selectedFirst = not temp.selectedFirst
                    print("Selection mode: "..(temp.selectedFirst and "First" or "Second"))
                elseif selection == 3 and temp.selectedAreaID then
                    net.start("removeArea")
                    net.writeFloat(temp.selectedAreaID)
                    net.send()
                end
            end
        else
            if R["Down"] != false then
                R["Down"] = false
                
            end
        end
        
        if M1["Pressed"] then
            if M1["Down"] != true then
                M1["Down"] = true
                if selection == 1 then
                    if not temp.firstPlaced then
                        temp.firstPlaced = owner():getEyeTrace().HitPos
                        temp.secondPlaced = temp.firstPlaced
                        temp.storez = temp.firstPlaced.z
                        temp.cornerSelected = 4
                        
                        temp.left_front = temp.firstPlaced
                        temp.right_front = Vector(temp.secondPlaced.x, temp.firstPlaced.y, temp.firstPlaced.z)
                        temp.left_back = Vector(temp.firstPlaced.x, temp.secondPlaced.y, temp.firstPlaced.z)
                        temp.right_back = temp.secondPlaced
                    end
                elseif selection == 2 or selection == 3 then
                    getNearestArea(owner():getEyeTrace().HitPos)
                end
            end
            if selection == 1 then
                if temp.firstPlaced then
                    if temp.secondPlaced then
                        temp.target = owner():getEyeTrace().HitPos
                        if temp.cornerSelected == 1 then
                            temp.left_front = Vector(temp.target.x, temp.target.y, temp.storez)
                            temp.right_front = Vector(temp.right_front.x, temp.target.y, temp.storez)
                            temp.left_back = Vector(temp.target.x, temp.left_back.y, temp.storez)

                        elseif temp.cornerSelected == 2 then
                            temp.right_front = Vector(temp.target.x, temp.target.y, temp.storez)
                            temp.left_front = Vector(temp.left_front.x, temp.target.y, temp.storez)
                            temp.right_back = Vector(temp.target.x, temp.right_back.y, temp.storez)

                        elseif temp.cornerSelected == 3 then
                            temp.left_back = Vector(temp.target.x, temp.target.y, temp.storez)
                            temp.right_back = Vector(temp.right_back.x, temp.target.y, temp.storez)
                            temp.left_front = Vector(temp.target.x, temp.left_front.y, temp.storez)

                        elseif temp.cornerSelected == 4 then
                            temp.right_back = Vector(temp.target.x, temp.target.y, temp.storez)
                            temp.left_back = Vector(temp.left_back.x, temp.target.y, temp.storez)
                            temp.right_front = Vector(temp.target.x, temp.right_front.y, temp.storez)
                        end

                        local minX = math.min(temp.left_front.x, temp.right_front.x, temp.left_back.x, temp.right_back.x)
                        local maxX = math.max(temp.left_front.x, temp.right_front.x, temp.left_back.x, temp.right_back.x)
                        local minY = math.min(temp.left_front.y, temp.right_front.y, temp.left_back.y, temp.right_back.y)
                        local maxY = math.max(temp.left_front.y, temp.right_front.y, temp.left_back.y, temp.right_back.y)
                        local z = temp.storez or temp.firstPlaced.z
                        temp.first = Vector(minX, minY, z)
                        temp.firstPlaced = temp.first
                        temp.second = Vector(maxX, maxY, z)
                        temp.secondPlaced = temp.second

                    else
                        temp.second = owner():getEyeTrace().HitPos
                    end
                else
                    temp.first = owner():getEyeTrace().HitPos
                end
            end

            if temp.secondPlaced then updateNearestCorner() end
        else
            if M1["Down"] != false then
                M1["Down"] = false
            end
            if temp.secondPlaced then
                updateNearestCorner()
            end
        end
    end)

    local boxmat = material.createFromImage("gui/contenticon-hovered.png","noclamp")
    local boxmatselection = material.createFromImage("gui/sm_hover.png","noclamp")
    local boxSize = 0.075
    local boxSizeSelected = 0.08
    local boxHeightOffset = 0.075
    local tool_icons = {}
    tool_icons[1] = material.createFromImage("icon16/brick_add.png","noclamp")
    tool_icons[2] = material.createFromImage("icon16/brick_link.png","noclamp")
    tool_icons[3] = material.createFromImage("icon16/brick_delete.png","noclamp")
    tool_icons[8] = material.createFromImage("icon16/book_edit.png","noclamp")
    tool_icons[9] = material.createFromImage("icon16/book_add.png","noclamp")
    
    local noicon = material.createFromImage("icon16/collision_off.png","noclamp")
    
    hook.add("drawhud","navmesh_drawhud",function()
        local w,h = render.getGameResolution()
        if controlsOK then
            if input.isKeyDown(KEY.LALT) then selectCT = timer.curtime() end
            local fade = input.isKeyDown(KEY.LALT) and 0 or math.clamp(3-(timer.curtime()-selectCT)*2,0,1)
            render.setColor(Color(255,255,255,255*(input.isKeyDown(KEY.LALT) and 1 or fade)))
            render.drawText(w/2,h - h*boxHeightOffset - h*boxSize*1.1, input.isKeyDown(KEY.LALT) and "Controls Unlocked!" or tools[selection], TEXT_ALIGN.CENTER)
            
            for i = 1, 9 do
                local isRightTool = (i == selection)
                if isRightTool then
                    render.setColor(Color(255,255,255,255*(0.2+0.8*fade)))
                else
                    render.setColor(Color(125,125,125,125*(0.2+0.8*fade)))
                end
                if tools[i] then
                    render.setMaterial(tool_icons[i])
                    render.drawTexturedRectRotated(w/2 - h*boxSize*9/2 + h*boxSize*(i-1) + h*boxSize/2, h - h*boxSize, h*boxSize*(0.55+(isRightTool and 0.1 or 0)), h*boxSize*(0.55+(isRightTool and 0.1 or 0)),0)
                else
                    render.setMaterial(noicon)
                    render.drawTexturedRectRotated(w/2 - h*boxSize*9/2 + h*boxSize*(i-1) + h*boxSize/2, h - h*boxSize, h*boxSize, h*boxSize,0)
                end
            end
            
            render.setMaterial(boxmat)
            for i = 1, 9 do
                if tools[i] then
                    render.setColor(Color(255,255,255,255*(0.2+0.8*fade)))
                else
                    render.setColor(Color(80,80,80,255*(0.2+0.8*fade)))
                end
                render.drawTexturedRectRotated(w/2 - h*boxSize*9/2 + h*boxSize*(i-1) + h*boxSize/2, h - h*boxSize, h*boxSize, h*boxSize,0)
            end
            
            
            render.setColor(Color(180,180,180,255*(0.1+0.9*fade)))
            render.setMaterial(boxmatselection)
            render.drawTexturedRectRotated(w/2 - h*boxSize*9/2 + h*boxSize*(selection-1) + h*boxSize/2, h - h*boxSize, h*boxSizeSelected, h*boxSizeSelected,0)
            render.setColor(Color(255,255,255,255))

            if temp.left_front then local pos = temp.left_front:toScreen(); render.drawCircle(pos.x,pos.y,5) end
            if temp.right_front then local pos = temp.right_front:toScreen(); render.drawCircle(pos.x,pos.y,5) end
            if temp.left_back then local pos = temp.left_back:toScreen(); render.drawCircle(pos.x,pos.y,5) end
            if temp.right_back then local pos = temp.right_back:toScreen(); render.drawCircle(pos.x,pos.y,5) end
            
            render.drawCircle(w/2, h/2, 3)
            
            for i, area in pairs(navArea) do
                if #area > 0 then
                    local lf = area[1]
                    local rf = area[2]
                    local lb = area[3]
                    local rb = area[4]
                    
                    local center = (lf+rf+lb+rb)/4
                    if center:getDistance(owner():getShootPos()) < 5000 then
                        local screen = center:toScreen()
                        if screen["visible"] or center:getDistance(owner():getShootPos()) < 500 then
                            render.setColor((temp.selectedAreaID and i == temp.selectedAreaID) and Color(255,0,0,255) or ((temp.selectedFirstID and i == temp.selectedFirstID) or (temp.selectedSecondID and i == temp.selectedSecondID)) and Color(0,255,0,255) or Color(255,255,255,255))
                            render.drawText(screen["x"],screen["y"],"ID: "..tostring(i), TEXT_ALIGN.LEFT)
                            
                            local left_front = lf:toScreen()
                            local right_front = rf:toScreen()
                            local left_back = lb:toScreen()
                            local right_back = rb:toScreen()
                            render.drawLine(left_front["x"], left_front["y"], left_back["x"], left_back["y"]) // lf to lb
                            render.drawLine(right_front["x"], right_front["y"], right_back["x"], right_back["y"]) // rf to rb
                            render.drawLine(left_front["x"], left_front["y"], right_front["x"], right_front["y"]) // lf to rf
                            render.drawLine(left_back["x"], left_back["y"], right_back["x"], right_back["y"]) // lb to rb
                            
                            render.setColor(Color(0,0,255,255))
                            if area.connections and #area.connections > 0 then
                                for i2, connection in pairs(area.connections) do
                                    local end_area = navArea[connection]
                                    if #end_area > 0 then
                                        local end_pos = ((end_area[1]+end_area[4])/2):toScreen()
                                        
                                        render.drawLine(screen["x"],screen["y"],end_pos["x"],end_pos["y"])
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end)
    hook.add("net","navmesh_client_net",function(name,len,ply)
        if name == "createAreaCallback" then
            local success = net.readBool()
            local token = net.readFloat()
            if success then
                local id = net.readFloat()
                local lf = net.readVector()
                local rf = net.readVector()
                local lb = net.readVector()
                local rb = net.readVector()
        
                navArea[id] = { lf, rf, lb, rb }
                
                lookupTable[token] = id
                
                savedCreateData[id] = pendingCreates[token]
            else
                pendingCreates[token] = nil
            end
        elseif name == "connectAreaCallback" then
            local id1 = net.readFloat()
            local id2 = net.readFloat()
        
            if navArea[id1] then
                navArea[id1].connections = navArea[id1].connections or {}
                if not table.hasValue(navArea[id1].connections, id2) then
                    table.insert(navArea[id1].connections, id2)
                    table.insert(savedCreateData[id1].connections,id2)
                end
            end
            if navArea[id2] then
                navArea[id2].connections = navArea[id2].connections or {}
                if not table.hasValue(navArea[id2].connections, id1) then
                    table.insert(navArea[id2].connections, id1)
                    table.insert(savedCreateData[id2].connections,id1)
                end
            end
        elseif name == "mapBuildComplete" then
            print("Navmesh build complete!")
            stillReading = false
        elseif name == "removeAreaCallback" then
            local id = net.readFloat()
            if navArea[id] then
                navArea[id] = nil
            end
            if savedCreateData[id] then
                savedCreateData[id] = nil
            end
            temp.selectedAreaID = nil
            for _, area in pairs(navArea) do
                if area.connections then
                    table.removeByValue(area.connections, id)
                end
            end
            for _, area in pairs(savedCreateData) do
                if area.connections then
                    table.removeByValue(area.connections, id)
                end
            end
        elseif name == "sendNearestToOwner" then
            local ok = net.readBool()
            local selectedAreaID = net.readFloat()
            if ok and selectedAreaID and selectedAreaID > 0 then
                if selection == 2 then
                    if temp.selectedFirst == true then
                        temp.selectedFirstID = selectedAreaID
                        print("First area ID: "..temp.selectedFirstID)
                    else
                        temp.selectedSecondID = selectedAreaID
                        print("Second area ID: "..temp.selectedSecondID)
                    end
                elseif selection == 3 then
                    temp.selectedAreaID = selectedAreaID
                end
            else
                print("Failed to find suitable area!")
            end
        end
    end)
end
