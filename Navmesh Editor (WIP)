--@name Nakilibs/Navmesh/Navmesh_Editor
--@author Nakkitsunami
--@shared

if SERVER then
    local areasData = {}
    local pendingMapData = {}
    local lookupTableIDS = {}
    
    local function sendCreateAreaCallback(success, id, lf, rf, lb, rb, token)
        net.start("createAreaCallback")
        net.writeBool(success)
        net.writeFloat(token or 0)
        if success then
            net.writeFloat(id)
            net.writeVector(lf)
            net.writeVector(rf)
            net.writeVector(lb)
            net.writeVector(rb)
        end
        net.send(owner())
    end

    local function createArea(from, to, token, originalID)
        local a = navmesh.createNavArea(from + Vector(0,0,25), to + Vector(0,0,25))
        if a then
            a:placeOnGround(NAV_CORNER.NUM_CORNERS)
            local id = a:getID()
            local lf = a:getCorner(NAV_CORNER.NORTH_WEST)
            local rf = a:getCorner(NAV_CORNER.NORTH_EAST)
            local lb = a:getCorner(NAV_CORNER.SOUTH_WEST)
            local rb = a:getCorner(NAV_CORNER.SOUTH_EAST)
            areasData[id] = { lf = lf, rf = rf, lb = lb, rb = rb, connections = areasData[id] and areasData[id].connections or {} }
            sendCreateAreaCallback(true, id, lf, rf, lb, rb, token)
            if areasData[id].connections then
                conntable = " : "..table.concat(areasData[id].connections, " ", 1, nil)
            else
                conntable = ""
            end
            if originalID then
                lookupTableIDS[tostring(originalID)] = id
            end
            
            printConsole("Area "..tostring(id)..": "..tostring(from).." "..tostring(to)..conntable)
            return a
        else
            sendCreateAreaCallback(false, 0, Vector(), Vector(), Vector(), Vector(), token)
            return nil
        end
    end
    
    local function sendConnectCallback(id1, id2)
        net.start("connectAreaCallback")
        net.writeFloat(id1)
        net.writeFloat(id2)
        net.send(owner())
    end
    
    local function connectAreas(id1, id2, oneway)
        if not isnumber(id1) or not isnumber(id2) then return false, "Given IDs are invalid!" end
        if not areasData[id1] or not areasData[id2] then return false, "Selected areas are invalid!" end
        local first = navmesh.getNavAreaByID(id1)
        local second = navmesh.getNavAreaByID(id2)
        
        areasData[id1].connections = areasData[id1].connections or {}
        areasData[id2].connections = areasData[id2].connections or {}
        if table.hasValue(areasData[id1].connections, id2) then
            return false, "Areas are already connected!"
        else
            areasData[id1].connections[#areasData[id1].connections+1] = id2
        end
        if not oneway then
            if table.hasValue(areasData[id2].connections, id1) then
                return false, "Areas are already connected!"
            else
                areasData[id2].connections[#areasData[id2].connections+1] = id1
            end
            if first:isValid() and second:isValid() then
                first:connectTo(second)
                second:connectTo(first)
            end
        else
            if first and second then
                first:connectTo(second)
            end
        end
        return true
    end
    
    function buildConnections(data)
        local conn_ct = 0
        local step = 1
        local ids = table.getKeys(data)

        hook.add("Think","build_connections",function()
            if timer.curtime() - conn_ct > 0.05 then
                local id = ids[step]
                if not id then
                    hook.remove("Think","build_connections")
                    net.start("mapBuildComplete")
                    net.send(owner())
                    return
                end
                local area = data[id]
                local id_this = lookupTableIDS[tostring(area.id)]
                for _,conn in ipairs(area.connections or {}) do
                    local id_that = lookupTableIDS[tostring(conn)]
                    local success, reason = connectAreas(id_this, id_that, true)
                    if success then
                        sendConnectCallback(id_this, id_that)
                    else
                        print("Failed to connect areas: "..reason)
                    end
                end
                conn_ct = timer.curtime()
                step = step + 1
            end
        end)
    end
    
    function buildMap(data)
        local build_map_ct = 0
        local build_map_iteration = 1
        local max = table.count(data)
        hook.add("Think","build_map",function()
            if timer.curtime() - build_map_ct > 0.1 then
                local token = build_map_iteration
                local area = data[token]
                if area then
                    createArea(area.from, area.to, token, area.id)
                end
                build_map_ct = timer.curtime()
                build_map_iteration = build_map_iteration + 1
                if build_map_iteration > max then
                    hook.remove("Think","build_map")
                    buildConnections(data)
                end
            end
        end)
    end

    
    hook.add("net", "navmesh_server_handler", function(name, len, ply)
        if name == "sendArea" then
            local token = net.readFloat()
            local from = net.readVector()
            local to = net.readVector()
            createArea(from, to, token)

        elseif name == "connectAreas" then
            local id1 = net.readFloat()
            local id2 = net.readFloat()
            local success, reason = connectAreas(id1, id2)
            if success then
                sendConnectCallback(id1, id2)
            else
                print("Failed to connect areas: "..reason)
            end
        elseif name == "nearestArea" then
            local findNearMe = net.readVector()
            local found = navmesh.getNavArea(findNearMe, 100)
            net.start("sendNearestToOwner")
            if found then
                net.writeBool(true)
                net.writeFloat(found:getID())
            else
                net.writeBool(false)
                net.writeFloat(-1)
            end
            net.send(owner())
        elseif name == "mapChunk" then
            local id = net.readUInt(16)
            local from = net.readVector()
            local to = net.readVector()
            local connStr = net.readString()
            local connections = {}
            if connStr ~= "" then
                for _,c in ipairs(string.explode(",", connStr)) do
                    connections[#connections+1] = tonumber(c)
                end
            end
            pendingMapData[#pendingMapData+1] = {id = id, from = from, to = to, connections = connections }
        elseif name == "mapUploadComplete" then
            buildMap(pendingMapData)
        elseif name == "removeArea" then
            local id = net.readFloat()
            local a = navmesh.getNavAreaByID(id)
            net.start("removeAreaCallback")
            if a then
                a:remove()
                net.writeFloat(id)
            else
                net.writeFloat(0)
            end
            net.send(owner())
        end
    end)

else -- CLIENT
    if player() ~= owner() then return end
    enableHud(owner(), true)
    local check_file_path = file.exists("nakilibs/navmesh/areas/default.txt")
    
    if not check_file_path then
        file.createDir("nakilibs/navmesh/areas/")
        file.write("nakilibs/navmesh/areas/default.txt", "")
        print("Folder structure created [data/sf_filedata/nakilibs/navmesh/]")
    end
    
    
    
    local mapname = game.getMap()
    local pendingCreates = {}
    local createTokenCounter = 0
    local savedCreateData = {}
    
    local navArea = {}
    local lookupTableIDS = {}
    
    local M1 = { Down = false }
    local R = { Down = false }
    local Enter = { Down = false }
    
    local tools = {
        [1] = "Create New Area",
        [2] = "Connect 2 Areas",
        [3] = "Select Area",
        [8] = "Load File",
        [9] = "Save File"
    }

    local selection = 1
    local selectCT = 0
    local controlsOK = false
    local controlsOKChanged = false
    local controlsOKCT = 0

    local temp = {}
    local targetWeapon = "none"
    local findWeapon = owner():getWeapon(targetWeapon)
    if findWeapon then
        input.selectWeapon(findWeapon)
    else
        print("Weapon \"none\" not found, select it to proceed..")
    end
    
    function getNearestArea(target)
        net.start("nearestArea")
        net.writeVector(target)
        net.send()
    end
    
    function saveMap()
        local lines = {}
        for id, create in pairs(savedCreateData) do
            if create then
                if create.from and create.to then
                    lines[#lines+1] = "areaid:"..id
                    lines[#lines+1] = string.format("%f %f %f %f %f %f", create.from.x, create.from.y, create.from.z, create.to.x, create.to.y, create.to.z)
                    if create.connections and #create.connections > 0 then
                        lines[#lines+1] = table.concat(create.connections, ",")
                    end
                end
            end
        end
        file.write("nakilibs/navmesh/areas/"..(mapname or game.getMap())..".txt", table.concat(lines,"\n"))
        print("File saved as "..mapname)
    end

    local function loadMap()
        local path = "nakilibs/navmesh/areas/"..(mapname or game.getMap())..".txt"
        local contents = file.read(path)
        if not contents or contents == "" then return end
        nav = {}
        savedCreateData = {}
        local lines = string.explode("\n", contents)
        local id, from, to, connections
        local step = 0
        local load_map_chunks_ct = 0
        local line_step = 1
        local sent = false
        hook.add("Think","load_map_chunks",function()
            if timer.curtime() - load_map_chunks_ct > 0.1 then
                local line = lines[line_step]
                if step == 0 then
                    if id and from and to then
                        net.start("mapChunk")
                        net.writeUInt(id,16)
                        net.writeVector(from)
                        net.writeVector(to)
                        savedCreateData[id] = {from = from, to = to}
                        if connections then
                            net.writeString(connections or "")
                            savedCreateData[id].connections = string.explode(",",connections,false)
                        end
                        net.send()
                    end
                    sent = true
                end
                if has_coords then
                    step = 2
                end
                if line_step > #lines then
                    if sent then
                        net.start("mapUploadComplete")
                        net.send()
                        hook.remove("Think","load_map_chunks")
                    end
                elseif line and line ~= "" then
                    line = string.trim(line)
                    if string.startsWith(line,"areaid:") then
                        id = tonumber(string.sub(line,8))
                        step = 1
                        line_step = line_step + 1
                    elseif step == 1 then
                        local nums = string.explode(" ", line)
                        from = Vector(tonumber(nums[1]),tonumber(nums[2]),tonumber(nums[3]))
                        to   = Vector(tonumber(nums[4]),tonumber(nums[5]),tonumber(nums[6]))
                        step = 2
                        line_step = line_step + 1
                        has_coords = true
                    elseif step == 2 then
                        if string.startsWith(line,"areaid:") then
                            step = 0
                        elseif has_coords then
                            connections = line
                            step = 0
                            line_step = line_step + 1
                        end
                        has_coords = false
                    end
                end
                
                load_map_chunks_ct = timer.curtime()
            end
        end)
    end


    hook.add("HUDShouldDraw", "navmesh_hud_should_draw", function(str)
        if owner():getActiveWeapon():getClass() ~= targetWeapon then return true end
        if str == "CHudCrosshair" then return false end
        if str == "CHudWeaponSelection" then
            if not input.isKeyDown(KEY.LALT) and owner():isTyping() == false then
                return false
            else
                return true
            end
        end
    end)

    hook.add("MouseWheeled","navmesh_wheel",function(delta)
        if (timer.curtime() - selectCT) < 0.05 or input.isKeyDown(KEY.LALT) or not controlsOK then return end
        if delta < 0 then
            selection = selection + 1
        elseif delta > 0 then
            selection = selection - 1
        end
        if selection < 1 then selection = 9 elseif selection > 9 then selection = 1 end
        while not tools[selection] do
            selection = (delta < 0) and (selection + 1) or (selection - 1)
            if selection < 1 then selection = 9 elseif selection > 9 then selection = 1 end
        end
        selectCT = timer.curtime()
        temp = {}
        if selection == 2 then
            temp.selectedFirst = true
        end
    end)

    local nearestDist = 1e18
    local function updateNearestCorner()
        if not (temp.left_front and temp.right_front and temp.left_back and temp.right_back) then return end
        local tr = owner():getEyeTrace().HitPos
        nearestDist = 1e18
        local best
        local d
        d = temp.left_front:getDistance(tr); if d < nearestDist then nearestDist = d; best = 1 end
        d = temp.right_front:getDistance(tr); if d < nearestDist then nearestDist = d; best = 2 end
        d = temp.left_back:getDistance(tr);  if d < nearestDist then nearestDist = d; best = 3 end
        d = temp.right_back:getDistance(tr); if d < nearestDist then nearestDist = d; best = 4 end
        temp.cornerSelected = best
    end

    hook.add("think","navmesh_think",function()
        controlsOK = (owner():isTyping() == false and owner():getActiveWeapon():getClass() == targetWeapon)
        if controlsOK then
            if not controlsOKChanged then
                controlsOKChanged = true
                controlsOKCT = timer.curtime()
                selectCT = timer.curtime()
            end
        else
            controlsOKChanged = false
        end

        M1.Pressed = input.isMouseDown(MOUSE.MOUSE1) and controlsOK
        R.Pressed = input.isKeyDown(KEY.R) and controlsOK
        Enter.Pressed = input.isKeyDown(KEY.ENTER) and controlsOK
        
        if Enter["Pressed"] then
            if Enter["Down"] != true then
                Enter["Down"] = true
                if selection == 1 then
                    if temp.secondPlaced then
                        
                        local origFrom = temp.firstPlaced
                        local origTo = temp.secondPlaced
                        
                        createTokenCounter = createTokenCounter + 1
                        local token = createTokenCounter
                        pendingCreates[token] = { from = origFrom, to = origTo }
                        net.start("sendArea")
                        net.writeFloat(token)
                        net.writeVector(origFrom)
                        net.writeVector(origTo)
                        net.send()
                        
                        temp = {}
                    end
                elseif selection == 2 then
                    if temp.selectedFirstID and temp.selectedSecondID then
                        net.start("connectAreas")
                        net.writeFloat(temp.selectedFirstID)
                        net.writeFloat(temp.selectedSecondID)
                        net.send()
                        
                        temp = {}
                        temp.selectedFirst = true
                    elseif temp.selectedFirstID or temp.selectedSecondID then
                        print("Only 1 Area Selected!")
                    else
                        print("No Areas Selected!")
                    end
                elseif selection == 8 then
                    loadMap()
                elseif selection == 9 then
                    saveMap()
                end
            end
        else
            if Enter["Down"] != false then
                Enter["Down"] = false
                
            end
        end
        
        if R["Pressed"] then
            if R["Down"] != true then
                R["Down"] = true
                if selection == 2 then
                    temp.selectedFirst = not temp.selectedFirst
                    print("Selection Type: "..(temp.selectedFirst and "First" or "Second"))
                elseif selection == 3 and temp.selectedAreaID then
                    net.start("removeArea")
                    net.writeFloat(temp.selectedAreaID)
                    net.send()
                end
            end
        else
            if R["Down"] != false then
                R["Down"] = false
                
            end
        end
        
        if M1["Pressed"] then
            if M1["Down"] != true then
                M1["Down"] = true
                if selection == 2 or selection == 3 then
                    getNearestArea(owner():getEyeTrace().HitPos)
                end
            end
            if selection == 1 then
                if temp.firstPlaced then
                    if temp.secondPlaced then
                        temp.target = owner():getEyeTrace().HitPos
                        if temp.cornerSelected == 1 then
                            temp.left_front = Vector(temp.target.x, temp.target.y, temp.storez)
                            temp.right_front = Vector(temp.right_front.x, temp.target.y, temp.storez)
                            temp.left_back = Vector(temp.target.x, temp.left_back.y, temp.storez)

                        elseif temp.cornerSelected == 2 then
                            temp.right_front = Vector(temp.target.x, temp.target.y, temp.storez)
                            temp.left_front = Vector(temp.left_front.x, temp.target.y, temp.storez)
                            temp.right_back = Vector(temp.target.x, temp.right_back.y, temp.storez)

                        elseif temp.cornerSelected == 3 then
                            temp.left_back = Vector(temp.target.x, temp.target.y, temp.storez)
                            temp.right_back = Vector(temp.right_back.x, temp.target.y, temp.storez)
                            temp.left_front = Vector(temp.target.x, temp.left_front.y, temp.storez)

                        elseif temp.cornerSelected == 4 then
                            temp.right_back = Vector(temp.target.x, temp.target.y, temp.storez)
                            temp.left_back = Vector(temp.left_back.x, temp.target.y, temp.storez)
                            temp.right_front = Vector(temp.target.x, temp.right_front.y, temp.storez)
                        end

                        local minX = math.min(temp.left_front.x, temp.right_front.x, temp.left_back.x, temp.right_back.x)
                        local maxX = math.max(temp.left_front.x, temp.right_front.x, temp.left_back.x, temp.right_back.x)
                        local minY = math.min(temp.left_front.y, temp.right_front.y, temp.left_back.y, temp.right_back.y)
                        local maxY = math.max(temp.left_front.y, temp.right_front.y, temp.left_back.y, temp.right_back.y)
                        local z = temp.storez or temp.firstPlaced.z
                        temp.first = Vector(minX, minY, z)
                        temp.firstPlaced = temp.first
                        temp.second = Vector(maxX, maxY, z)
                        temp.secondPlaced = temp.second

                    else
                        temp.second = owner():getEyeTrace().HitPos
                    end
                else
                    temp.first = owner():getEyeTrace().HitPos
                end
            end

            if temp.secondPlaced then updateNearestCorner() end
        else
            if M1["Down"] != false then
                M1["Down"] = false
                if temp.first then
                    if temp.second and not temp.secondPlaced then
                        temp.secondPlaced = Vector(temp.second.x, temp.second.y, temp.storez)
                        print("Second location placed!")
                    elseif not temp.firstPlaced then
                        temp.firstPlaced = temp.first
                        temp.storez = temp.firstPlaced.z
                        print("First location placed!")
                    elseif temp.secondPlaced then
                        if temp.cornerSelected then
                            print("Adjusted "..select(temp.cornerSelected,"left front","right front","left back","right back").." corner!")
                        end
                    end
                end
            end

            if temp.secondPlaced then
                temp.left_front = temp.firstPlaced
                temp.right_front = Vector(temp.secondPlaced.x, temp.firstPlaced.y, temp.firstPlaced.z)
                temp.left_back = Vector(temp.firstPlaced.x, temp.secondPlaced.y, temp.firstPlaced.z)
                temp.right_back = temp.secondPlaced

                updateNearestCorner()
            end
        end
    end)

    local boxmat = material.createFromImage("gui/contenticon-hovered.png","noclamp smooth")
    local boxmatselection = material.createFromImage("gui/sm_hover.png","noclamp smooth")
    local boxSize = 0.075
    local boxSizeSelected = 0.08
    local boxHeightOffset = 0.075

    hook.add("drawhud","navmesh_drawhud",function()
        local w,h = render.getGameResolution()
        if controlsOK then
            if input.isKeyDown(KEY.LALT) then selectCT = timer.curtime() end
            local fade = input.isKeyDown(KEY.LALT) and 0 or math.clamp(3-(timer.curtime()-selectCT)*2,0,1)
            render.setColor(Color(255,255,255,255*(input.isKeyDown(KEY.LALT) and 1 or fade)))
            render.drawText(w/2,h - h*boxHeightOffset - h*boxSize*1.1, tools[selection] or "", TEXT_ALIGN.CENTER)
            render.setColor(Color(255,255,255,255*(0.2+0.8*fade)))
            render.setMaterial(boxmat)
            for i = 1, 9 do
                render.drawTexturedRectRotated(w/2 - h*boxSize*9/2 + h*boxSize*(i-1) + h*boxSize/2, h - h*boxSize, h*boxSize, h*boxSize,0)
            end
            render.setColor(Color(180,180,180,255*(0.1+0.9*fade)))
            render.setMaterial(boxmatselection)
            render.drawTexturedRectRotated(w/2 - h*boxSize*9/2 + h*boxSize*(selection-1) + h*boxSize/2, h - h*boxSize, h*boxSizeSelected, h*boxSizeSelected,0)
            render.setColor(Color(255,255,255,255))

            if temp.left_front then local pos = temp.left_front:toScreen(); render.drawCircle(pos.x,pos.y,5) end
            if temp.right_front then local pos = temp.right_front:toScreen(); render.drawCircle(pos.x,pos.y,5) end
            if temp.left_back then local pos = temp.left_back:toScreen(); render.drawCircle(pos.x,pos.y,5) end
            if temp.right_back then local pos = temp.right_back:toScreen(); render.drawCircle(pos.x,pos.y,5) end
            
            render.drawCircle(w/2, h/2, 3)
            
            for i, area in pairs(navArea) do
                if #area > 0 then
                    local lf = area[1]
                    local rf = area[2]
                    local lb = area[3]
                    local rb = area[4]
                    
                    local center = (lf+rf+lb+rb)/4
                    if center:getDistance(owner():getShootPos()) < 1000 then
                        local screen = center:toScreen()
                        if screen["visible"] or center:getDistance(owner():getShootPos()) < 200 then
                            render.setColor((temp.selectedAreaID and i == temp.selectedAreaID) and Color(255,0,0,255) or ((temp.selectedFirstID and i == temp.selectedFirstID) or (temp.selectedSecondID and i == temp.selectedSecondID)) and Color(0,255,0,255) or Color(255,255,255,255))
                            render.drawText(screen["x"],screen["y"],"ID: "..tostring(i), TEXT_ALIGN.LEFT)
                            
                            local left_front = lf:toScreen()
                            local right_front = rf:toScreen()
                            local left_back = lb:toScreen()
                            local right_back = rb:toScreen()
                            render.drawLine(left_front["x"], left_front["y"], left_back["x"], left_back["y"]) // lf to lb
                            render.drawLine(right_front["x"], right_front["y"], right_back["x"], right_back["y"]) // rf to rb
                            render.drawLine(left_front["x"], left_front["y"], right_front["x"], right_front["y"]) // lf to rf
                            render.drawLine(left_back["x"], left_back["y"], right_back["x"], right_back["y"]) // lb to rb
                            
                            render.setColor(Color(0,0,255,255))
                            if area.connections and #area.connections > 0 then
                                for i2, connection in pairs(area.connections) do
                                    local end_area = navArea[connection]
                                    if #end_area > 0 then
                                        local end_pos = ((end_area[1]+end_area[4])/2):toScreen()
                                        
                                        render.drawLine(screen["x"],screen["y"],end_pos["x"],end_pos["y"])
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end)
    hook.add("net","navmesh_client_net",function(name,len,ply)
        if name == "createAreaCallback" then
            local success = net.readBool()
            local token = net.readFloat()
            if success then
                local id = net.readFloat()
                local lf = net.readVector()
                local rf = net.readVector()
                local lb = net.readVector()
                local rb = net.readVector()
                navArea[id] = { lf, rf, lb, rb }
                if pendingCreates[token] then
                    savedCreateData[id] = pendingCreates[token]
                    lookupTableIDS[tostring(token)] = id
                    pendingCreates[token] = nil
                end
            else
                pendingCreates[token] = nil
            end

        elseif name == "connectAreaCallback" then
            local id1 = net.readFloat()
            local id2 = net.readFloat()
            if navArea[id1] then
                navArea[id1].connections = navArea[id1].connections or {}
                if not table.hasValue(navArea[id1].connections,id2) then table.insert(navArea[id1].connections,id2) end
                
                savedCreateData[id1] = savedCreateData[id1] or {}
                savedCreateData[id1].connections = savedCreateData[id1].connections or {}
                if not table.hasValue(savedCreateData[id1].connections,id2) then table.insert(savedCreateData[id1].connections,id2) end
            end
            if navArea[id2] then
                navArea[id2].connections = navArea[id2].connections or {}
                if not table.hasValue(navArea[id2].connections,id1) then table.insert(navArea[id2].connections,id1) end
                
                savedCreateData[id2] = savedCreateData[id2] or {}
                savedCreateData[id2].connections = savedCreateData[id2].connections or {}
                if not table.hasValue(savedCreateData[id2].connections,id1) then table.insert(savedCreateData[id2].connections,id1) end
            end
        elseif name == "mapBuildComplete" then
            print("Navmesh build complete!")
        elseif name == "removeAreaCallback" then
            local id = net.readFloat()
            if id > 0 then
                print("Area removed Successfully!")
                local navAreaEntry = navArea[id]
                if navAreaEntry then
                    navArea[id] = {}
                    print("found in navArea")
                end
                local savedAreaEntry = savedCreateData[lookupTableIDS[id]]
                if savedAreaEntry then
                    savedCreateData[lookupTableIDS[id]] = {}
                    print("found in savedCreateData")
                end
            else
                print("Couldn't remove area!")
            end
        elseif name == "sendNearestToOwner" then
            local ok = net.readBool()
            local selectedAreaID = net.readFloat()
            if ok and selectedAreaID and selectedAreaID > 0 then
                if selection == 2 then
                    if temp.selectedFirst == true then
                        temp.selectedFirstID = selectedAreaID
                        print("First area ID: "..temp.selectedFirstID)
                    else
                        temp.selectedSecondID = selectedAreaID
                        print("Second area ID: "..temp.selectedSecondID)
                    end
                elseif selection == 3 then
                    temp.selectedAreaID = selectedAreaID
                end
            else
                print("Failed to find suitable area!")
            end
        end
    end)
end
