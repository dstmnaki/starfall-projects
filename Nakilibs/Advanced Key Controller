--@name nakilibs/Advanced Key Controller
--@author Nakkitsunami
--@client
-- Neat input detection library


// Initializing functions for library use
local _player = nil

adv_key_ctrl = {}
adv_key_ctrl.keys = {} -- This one can be used to get all keys that are being listened to
                        -- Note it returns the full tables including functions, aka a lot of information, do not printTable it

// Debug mode, you can check for input detection through this, '0,1,2' - none, creation, creation + detection
local _DEBUG = 0


// Use this to assign the player you are listening for controls (other clients require networking through server, back to owner!)
function adv_key_ctrl.assign_listener(player)
    if not isValid(player) then _player = nil return end
    _player = player
end

// Alternative for clearing listener target, you can use the function above with "nil" as the target
function adv_key_ctrl.clear_listener()
    _player = nil
end

// The function called when adding buttons to listen
function adv_key_ctrl.configure_key(custom_key_name, key_string, down_once_callback, down_repeat_callback, up_once_callback, up_repeat_callback)
    local key_string_upper = key_string:upper()
    
    if adv_key_ctrl.keys[key_string_upper] != nil then print(key_string_upper.." is mapped already! Skipping...") return end
    
    local ex = string.explode(".", key_string_upper)
    
    if #ex != 2 then print(custom_key_name.." missing either type or name! use the format \"TYPE.KEY\"") return end
    
    local expect_type = ex[1]
    local expect_key = ex[2]
    
    if expect_type != "KEY" and expect_type != "MOUSE" and expect_type != "IN_KEY" then
        if _DEBUG > 0 then
            print(custom_key_name.." has incorrect type! "..expect_type.." defaulting to KEY")
        end
        expect_type = "KEY"
    end
    
    local _target_key = _G[expect_type][expect_key]
    
    if not _target_key then
        print(expect_type.." does not have value "..expect_key.."!")
        return
    end
    
    adv_key_ctrl.keys[key_string_upper] = {}
    local t = adv_key_ctrl.keys[key_string_upper]
    
    t._key_name = custom_key_name
    
    t._key = _target_key
    t._type = expect_type
    
    t._pressed_f_once = down_once_callback
    t._pressed_f_repeat = down_repeat_callback
    
    t._released_f_once = up_once_callback
    t._released_f_repeat = up_repeat_callback
    
    t._down = false
    t._down_ct = 0
    
    if _DEBUG > 0 then
        print("Input configured: '"..expect_type.."."..expect_key.."' of type '"..t._type.."' custom name '"..custom_key_name.."'")
    end
end

--[[
            EXAMPLE USAGE
--]]

// Simplest callback functions
function down_once_callback(pressed_ct)
    print("This repeats only once when button is pressed")
end

function down_repeat_callback(pressed_ct)
    print("This repeats when button is held down")
end

function up_once_callback(pressed_ct)
    print("This repeats only once when button is released")
end

// This one allows you to get an output when a button is not down, repeatedly
// you shouldn't be doing anything that uses this, set variables etc once in the function above
function up_repeat_callback(pressed_ct)
    if BLOCK != true then
        BLOCK = true
        print("This repeats when button is not held down, use sparingly!")
    end
end

// Adding a button
adv_key_ctrl.configure_key(
"Mmm the M button", -- Button name, completely custom
"KEY.M", -- The button, in string form
down_once_callback, -- Down once callback function, listed above, same for rest
down_repeat_callback, -- Down repeat callback function, these also are given the time when the button was pressed
up_once_callback, -- Released once callback function, if you take the time the button was pressed, negate the time from this from it, you get the time the button was held down
up_repeat_callback -- Released repeat callback function, just in case you need it for something, should be avoided tho
)

// Assigning a player that will be listened for inputs, if not owner, network it through server, back to you, otherwise you won't know that they are actually pressing something
adv_key_ctrl.assign_listener(owner())

// The main loop
hook.add("Think","_advanced_key_controller_main",function()
    if not isValid(_player) then return end
    if player() != _player then return end
    for k, v in pairs(adv_key_ctrl.keys) do
        local _type = v._type
        local _key = v._key
        local _key_name = v._key_name -- This is purely for debug purposes, it's not required for this to function
        if _type == "KEY" then
            if input.isKeyDown(_key) then
                if v._down != true then
                    v._down = true
                    v._down_ct = timer.curtime()
                    if v._pressed_f_once != nil then
                        v._pressed_f_once(v._down_ct)
                    end
                    if _DEBUG == 2 then
                        print(tostring(_key_name).." pressed!")
                    end
                end
                if v._pressed_f_repeat != nil then
                    v._pressed_f_repeat(v._down_ct)
                end
            else
                if v._down != false then
                    v._down = false
                    v._down_ct = timer.curtime()
                    if v._released_f_once != nil then
                        v._released_f_once(v._down_ct)
                    end
                    if _DEBUG == 2 then
                        print(tostring(_key_name).." pressed!")
                    end
                end
                if v._released_f_repeat != nil then
                    v._released_f_repeat(v._down_ct)
                end
            end
        elseif _type == "MOUSE" then
            if input.isMouseDown(_key) then
                if v._down != true then
                    v._down = true
                    v._down_ct = timer.curtime()
                    if v._pressed_f_once != nil then
                        v._pressed_f_once(v._down_ct)
                    end
                    if _DEBUG == 2 then
                        print(tostring(_key_name).." pressed!")
                    end
                end
                if v._pressed_f_repeat != nil then
                    v._pressed_f_repeat(v._down_ct)
                end
            else
                if v._down != false then
                    v._down = false
                    v._down_ct = timer.curtime()
                    if v._released_f_once != nil then
                        v._released_f_once(v._down_ct)
                    end
                    if _DEBUG == 2 then
                        print(tostring(_key_name).." pressed!")
                    end
                end
                if v._released_f_repeat != nil then
                    v._released_f_repeat(v._down_ct)
                end
            end
        elseif _type == "IN_KEY" then
            if player:keyDown(_key) then
                if v._down != true then
                    v._down = true
                    v._down_ct = timer.curtime()
                    if v._pressed_f_once != nil then
                        v._pressed_f_once(v._down_ct)
                    end
                    if _DEBUG == 2 then
                        print(tostring(_key_name).." pressed!")
                    end
                end
                if v._pressed_f_repeat != nil then
                    v._pressed_f_repeat(v._down_ct)
                end
            else
                if v._down != false then
                    v._down = false
                    v._down_ct = timer.curtime()
                    if v._released_f_once != nil then
                        v._released_f_once(v._down_ct)
                    end
                    if _DEBUG == 2 then
                        print(tostring(_key_name).." pressed!")
                    end
                end
                if v._released_f_repeat != nil then
                    v._released_f_repeat(v._down_ct)
                end
            end
        end
    end
end)
