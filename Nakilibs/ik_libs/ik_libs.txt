--@name nakilibs/ik_libs/ik_libs
--@author Nakkitsunami
--@include nakilibs/ik_libs/shared.txt
--@client
require("nakilibs/ik_libs/shared.txt")

ik_libs = ik_libs or {}

function ik_libs.digi_ik_shadowscion(BoneTable, Target, Rotation, OffsetRotation)
    local LengthA = BoneTable["Length_A"]
    local LengthB = BoneTable["Length_B"]
    local LengthC = BoneTable["Length_C"]
    
    local Base = BoneTable["Base"]
    
    local HipA = BoneTable["Hip_A"]
    local HipB = BoneTable["Hip_B"]
    local Knee = BoneTable["Knee"]
    local Ankle = BoneTable["Ankle"]
    local Foot = BoneTable["Foot"]
    
    if not (LengthA and LengthB and LengthC) then return end
    if not (Base and Base != nil and Base:isValid()) then return end
    if not (HipA and HipA != nil and HipA:isValid()) then return end
    if not (HipB and HipB != nil and HipB:isValid()) then return end
    if not (Knee and Knee != nil and Knee:isValid()) then return end
    if not (Ankle and Ankle != nil and Ankle:isValid()) then return end
    if not (Foot and Foot != nil and Foot:isValid()) then return end
    
    local AxisWorld = Target - HipA:getPos()
    local AxisLocal = ik_libs.toLocalAxis(Base,AxisWorld)
    
    HipA:setAngles(Base:localToWorldAngles(Angle(0,0,math.deg(math.atan2(math.rad(AxisLocal.z),math.rad(AxisLocal.y))) + Rotation)))
    
    local AxisLocal = ik_libs.toLocalAxis(HipA,AxisWorld)
    local Fraction = 1 - math.min(1, HipB:getPos():getDistance(Target) / (LengthA + LengthC) - 0.5) + OffsetRotation
    
    HipB:setAngles(HipA:localToWorldAngles(Angle(math.deg(math.atan2(math.rad(-AxisLocal.x),math.rad(AxisLocal.z))) + 90*Fraction, 180, 0)))
    
    local AxisLocal = ik_libs.toLocalAxis(HipA,(Target - Knee:getPos()))
    local Distance = math.min(AxisLocal:getLength(), LengthB + LengthC)
    
    Knee:setAngles(HipA:localToWorldAngles(Angle(math.deg(math.atan2(math.rad(AxisLocal.x),math.rad(AxisLocal.z))) + ik_libs.icos(Distance, LengthB, LengthC), 0, 0)))
    Ankle:setAngles(Knee:localToWorldAngles(Angle(ik_libs.icos(LengthC, LengthB, Distance) + 180, 0, 0)))
    Foot:setAngles(Base:getAngles())
end

function ik_libs.arachnid(BoneTable, Target, Rotation, OffsetRotation)
    local LengthA = BoneTable["Length_A"]
    local LengthB = BoneTable["Length_B"]
    local LengthC = BoneTable["Length_C"]
    
    local Base = BoneTable["Base"]
    
    local HipA = BoneTable["Hip_A"]
    local HipB = BoneTable["Hip_B"]
    local Knee = BoneTable["Knee"]
    local Ankle = BoneTable["Ankle"]
    
    if not (LengthA and LengthB and LengthC) then return end
    if not (Base and Base != nil and Base:isValid()) then return end
    if not (HipA and HipA != nil and HipA:isValid()) then return end
    if not (HipB and HipB != nil and HipB:isValid()) then return end
    if not (Knee and Knee != nil and Knee:isValid()) then return end
    if not (Ankle and Ankle != nil and Ankle:isValid()) then return end
    
    local AxisWorld = Target - HipA:getPos()
    local AxisLocal = ik_libs.toLocalAxis(Base,AxisWorld)
    
    HipA:setAngles(Base:localToWorldAngles(Angle(0,0,math.deg(math.atan2(math.rad(AxisLocal.z),math.rad(AxisLocal.y))) + Rotation)))
    
    local AxisLocal = ik_libs.toLocalAxis(HipA,AxisWorld)
    local Fraction = 1 - math.min(1, HipB:getPos():getDistance(Target) / (LengthA + LengthC) - 0.5) + OffsetRotation
    
    HipB:setAngles(HipA:localToWorldAngles(Angle(math.deg(math.atan2(math.rad(-AxisLocal.x),math.rad(AxisLocal.z))) + 90*Fraction, 180, 0)))
    
    local AxisLocal = ik_libs.toLocalAxis(HipA,(Target - Knee:getPos()))
    local Distance = math.min(AxisLocal:getLength(), LengthB + LengthC)
    
    Knee:setAngles(HipA:localToWorldAngles(Angle(math.deg(math.atan2(math.rad(AxisLocal.x),math.rad(AxisLocal.z))) + ik_libs.icos(Distance, LengthB, LengthC), 0, 0)))
    Ankle:setAngles(Knee:localToWorldAngles(Angle(ik_libs.icos(LengthC, LengthB, Distance) + 180, 0, 0)))
end

function ik_libs.two_seg_ik_shadowscion(BoneTable, Target)
    local LengthA = BoneTable["Length_A"]
    local LengthB = BoneTable["Length_B"]
    
    local Base = BoneTable["Base"]
    
    local HipA = BoneTable["Hip_A"]
    local HipB = BoneTable["Hip_B"]
    local Knee = BoneTable["Knee"]
    local Foot = BoneTable["Foot"]
    
    local reverseKnee = BoneTable["Reversed"] == false
    
    if not (LengthA and LengthB) then return end
    if not (Base and Base != nil and Base:isValid()) then return end
    if not (HipA and HipA != nil and HipA:isValid()) then return end
    if not (HipB and HipB != nil and HipB:isValid()) then return end
    if not (Knee and Knee != nil and Knee:isValid()) then return end
    if not (Foot and Foot != nil and Foot:isValid()) then return end
    
    local AxisWorld = Target - HipA:getPos()
    local AxisLocal = ik_libs.toLocalAxis(Base,AxisWorld)
    
    HipA:setAngles(Base:localToWorldAngles(Angle(0,0,math.deg(math.atan2(math.rad(AxisLocal.z),math.rad(AxisLocal.y))) + 90)))
    
    local AxisLocal = ik_libs.toLocalAxis(HipA,(Target - HipB:getPos()))
    local Distance = math.min(AxisLocal:getLength(), LengthA + LengthB)
    
    if reverseKnee then
        HipB:setAngles(HipA:localToWorldAngles(Angle(math.deg(math.atan2(math.rad(AxisLocal.x),math.rad(AxisLocal.z))) + ik_libs.icos(Distance, LengthA, LengthB), 0, 0)))
    else
        HipB:setAngles(HipA:localToWorldAngles(Angle(math.deg(math.atan2(math.rad(-AxisLocal.x),math.rad(AxisLocal.z))) + ik_libs.icos(Distance, LengthA, LengthB), 180, 0)))
    end
    
    Knee:setAngles(HipB:localToWorldAngles(Angle(ik_libs.icos(LengthB, LengthA, Distance) + 180, 0, 0)))
    Foot:setAngles(Base:getAngles())
end

function ik_libs.four_segment_ik(BoneTable, Target)
    local LengthA = BoneTable["Length_A"]
    local LengthB = BoneTable["Length_B"]
    local LengthC = BoneTable["Length_C"]
    local LengthD = BoneTable["Length_D"]
    
    local Base = BoneTable["Base"]
    
    local H1 = BoneTable["H1"]
    local H2 = BoneTable["H2"]
    local H3 = BoneTable["H3"]
    local H4 = BoneTable["H4"]
    
    local reverseKnee = BoneTable["Reversed"] == true
    
    if not (LengthA and LengthB and LengthC and LengthD) then return end
    if not (Base and Base != nil and Base:isValid()) then return end
    if not (H1 and H1 != nil and H1:isValid()) then return end
    if not (H2 and H2 != nil and H2:isValid()) then return end
    if not (H3 and H3 != nil and H3:isValid()) then return end
    if not (H4 and H4 != nil and H4:isValid()) then return end
    
    local Origin = H1:getPos()
    local AxisLocal = ik_libs.toLocalAxis(Base,Target - Origin)
    
    local AxisAngle = AxisLocal:getAngle()
    if reverseKnee then
        AxisAngle.r = -ik_libs.bearing(Origin, Base:getAngles(), Target)
    else
        AxisAngle.r = -ik_libs.bearing(Target, Base:getAngles(), Origin)
    end
    
    local First2 = (LengthA + LengthB)*1
    local Second2 = (LengthC + LengthD)/2.5
    
    local LengthX = math.min(AxisLocal:getLength(), First2+Second2)
    local AxisQuat = (AxisAngle):getQuaternion() * ik_libs.qRotation(Vector(0, 1, 0), ik_libs.icos(LengthX, First2, Second2))
    
    H1:setAngles(Base:localToWorldAngles(AxisQuat:getEulerAngle()))
    
    local Origin = H2:getPos()
    local AxisLocal = ik_libs.toLocalAxis(H1, Target - Origin)
    
    local AxisAngle = AxisLocal:getAngle()
    if reverseKnee then
        AxisAngle.r = -ik_libs.bearing(Target, H1:getAngles(), Origin)
    else
        AxisAngle.r = -ik_libs.bearing(Origin, H1:getAngles(), Target)
    end
    
    local H2_Dist = ik_libs.toLocalAxis(H2, Target - Origin):getLength()
    local AddMult = math.clamp(H2_Dist / (LengthB + LengthC + LengthD), 0, 1)
    
    local Mult = 1.41 - 0.4 * math.clamp((-8.75 + AddMult * 10) / 1.25, 0, 1)
    local Length_A = LengthB + math.clamp(LengthC * (H2_Dist / (LengthB + LengthC)) * Mult, 0, LengthC * Mult)
    local Mult2 = (0.6 + 0.4 * AddMult) * math.clamp(-1 + (0.5 + math.sin(math.rad(AddMult * 180))) * 2, 0.1, 1)
    
    local MultFirst = 0.3 * AddMult
    local MultSecond = 0.9 * (1 - AddMult) + math.clamp(3 * AddMult, 0, 1) * 1.5
    
    local Length_D = LengthD * (0.7 + MultFirst) + LengthC * (-(2 - 1.5 * AddMult) + MultSecond) * math.sin(math.rad(AddMult * 180))
    local Length_B = Length_D + math.clamp(LengthC * (1 - (H2_Dist / (LengthC + LengthD))) * Mult2, 0, LengthC * Mult2)
    
    local LengthX = math.min(AxisLocal:getLength(), Length_A + Length_B)
    local AxisQuat = AxisAngle:getQuaternion() * ik_libs.qRotation(Vector(0, 1, 0), 70 * (1 - AddMult) + ik_libs.icos(LengthX, Length_A, Length_B))
    
    H2:setAngles(H1:localToWorldAngles(AxisQuat:getEulerAngle()))
    
    local Origin = H3:getPos()
    local AxisLocal = ik_libs.toLocalAxis(H2,Target - Origin)
    
    local AxisAngle = AxisLocal:getAngle()
    AxisAngle.r = (-ik_libs.bearing(Origin, H2:getAngles(), Target)) -- forward knee
    
    local LengthX = math.min(AxisLocal:getLength(), (LengthC + LengthD))
    local AxisQuat = (AxisAngle):getQuaternion() * ik_libs.qRotation(Vector(0, 1, 0), ik_libs.icos(LengthX, LengthC, LengthD))
    
    H3:setAngles(H2:localToWorldAngles(AxisQuat:getEulerAngle()))
    H4:setAngles(H3:localToWorldAngles(Angle(ik_libs.icos(LengthC, LengthD, LengthX) + 180, 0, 0)))
end
