--@name Dark Souls 3 Area Name Display
--@author Nakkitsunami
--@client
--@owneronly

--   SETTINGS   --



// Display name
local AREA_NAME = "The Name of Area"

// The box must be oriented towards north, it will not be rotated if you rotate the area while duping for example
// If any of the directions are flipped, the code will fix it, it will also print it in chat
// You should flip the specified coordinates yourself if that happens
local Pos1 = chip():getPos()+Vector(-250,-250,-1)
local Pos2 = chip():getPos()+Vector(250,250,250)

// Global toggle for playing the dark souls 3 sound for entering an area
local _USE_SOUND = true

// Draws a box around the area
local _DEBUG_LINES = true



--     CODE     --

setName(AREA_NAME)
local _snd = nil
if _USE_SOUND then
    bass.loadURL("https://raw.githubusercontent.com/dstmnaki/starfall-projects/refs/heads/main/ds3_new_area_snd.mp3", "3d noblock noplay", function(snd)
        if snd then
            _snd = snd
            _snd:pause()
            _snd:setTime(0,true)
            _snd:setLooping(false)
            _snd:setFade(1000, 1500, true)
        end
    end)
end
local rtName = "area_name_display"
render.createRenderTarget(rtName)

local name_plate = material.create("VertexLitGeneric")
name_plate:setTextureRenderTarget("$basetexture", rtName)
name_plate:setFloat("$alpha",1)

local font = render.createFont("Times New Roman", 50, 400, true, false, true, false, 0, false, false)

local line_original = material.load("particle/Particle_Glow_04")
local line = material.create("UnlitGeneric")
line:setTexture("$basetexture", line_original:getTexture("$basetexture"))
line:setFloat("$alpha",1)

function inrange( vec,  min,  max)
    if vec[1] <= min[1] then return false end
    if vec[2] <= min[2] then return false end
    if vec[3] <= min[3] then return false end

    if vec[1] >= max[1] then return false end
    if vec[2] >= max[2] then return false end
    if vec[3] >= max[3] then return false end

    return true
end
timer.simple(0.1,function()
    hook.add("renderscene", "_create_name_display", function(origin, angles, fov)
        render.selectRenderTarget(rtName)
        render.clear(Color(0,0,0,0))
        
        
        render.setColor(Color(0,0,0,125))
        render.setMaterial(line)
        render.drawTexturedRectRotated(512+512*0.5, 512, 1024*1.25*0.25, 8, 0)
        render.drawTexturedRectRotated(512+512*0.3, 512, 1024*1.25*0.4, 8, 0)
        render.drawTexturedRectRotated(512, 512, 1024*1.25*0.6, 8, 0)
        render.drawTexturedRectRotated(512-512*0.3, 512, 1024*1.25*0.4, 8, 0)
        render.drawTexturedRectRotated(512-512*0.5, 512, 1024*1.25*0.25, 8, 0)
        
        render.setColor(Color(240,240,240,255))
        render.drawTexturedRectRotated(512+512*0.4, 512, 1024*1.25*0.35, 5, 0)
        render.drawTexturedRectRotated(512+512*0.2, 512, 1024*1.25*0.4, 5, 0)
        render.drawTexturedRectRotated(512, 512, 1024*1.25*0.6, 5, 0)
        render.drawTexturedRectRotated(512-512*0.2, 512, 1024*1.25*0.4, 5, 0)
        render.drawTexturedRectRotated(512-512*0.4, 512, 1024*1.25*0.35, 5, 0)
        
        render.setFont(font)
        render.setColor(Color(0,0,0,90))
        render.drawText(512-1, 512-41-1, AREA_NAME, TEXT_ALIGN.CENTER)
        render.drawText(512+1, 512-41+1, AREA_NAME, TEXT_ALIGN.CENTER)
        
        render.setColor(Color(255,255,255,255))
        render.drawText(512, 512-41, AREA_NAME, TEXT_ALIGN.CENTER)
        
        
        render.selectRenderTarget()
        hook.remove("renderscene","_create_name_display")
    end)
end)
local w, h = render.getGameResolution()

local tex = hologram.create(chip():getPos()+Vector(0,0,-23.5+3), Angle(), "models/hunter/blocks/cube1x1x1.mdl", Vector(1,1*w/1920*1.3,0.85*h/1080*1.3))
tex:setClip(1, true, Vector(-23.5,0,0), Vector(-1,0,0), tex)
tex:suppressEngineLighting(true)
tex:setMaterial("!"..name_plate:getName())
tex:setColor(Color(255,255,255,254))
tex:setRenderMode(RENDERMODE.WORLDGLOW)

local in_area = false
local enter_ct = timer.curtime()-5

if Pos1.x > Pos2.x then 
    local store1 = Pos1.x
    local store2 = Pos2.x
    Pos1.x = store2
    Pos2.x = store1
    print("Flipped X Coordinates!")
end
if Pos1.y > Pos2.y then 
    local store1 = Pos1.y
    local store2 = Pos2.y
    Pos1.y = store2
    Pos2.y = store1
    print("Flipped Y Coordinates!")
end
if Pos1.z > Pos2.z then 
    local store1 = Pos1.z
    local store2 = Pos2.z
    Pos1.z = store2
    Pos2.z = store1
    print("Flipped Z Coordinates!")
end

hook.add("RenderOffscreen","",function()
    
    local pos = eyePos()
    
    if inrange(pos,Pos1,Pos2) then
        if in_area != true then
            in_area = true
            if _snd != nil then
                _snd:setPos(pos)
                _snd:play()
                _snd:setVolume(3)
                _snd:setTime(0,true)
            end
            enter_ct = timer.curtime()
        end
    else
        if math.clamp(timer.curtime()-enter_ct,0,5)/5 >= 1 then
            if in_area != false then
                in_area = false
            end
        end
    end
    
    local dt = math.clamp(timer.curtime()-enter_ct,0,5)/5
    local animation_time = math.clamp(math.sin(math.rad(dt*180))*(3.5-(dt>=0.5 and 1 or 0)),0,1)
    
    if not (in_area or dt < 1) then tex:setColor(Color(255,255,255,0)) return end
    
    local ang = eyeAngles()
    
    tex:setPos(pos+ang:getForward()*(25+24))
    tex:setAngles(ang)
    tex:setColor(Color(255,255,255,254*animation_time))
end)

if player() == owner() and _DEBUG_LINES then
    enableHud(owner(),true)
    hook.add("DrawHUD","",function()
        if not Pos1 and Pos2 then return end
        render.setColor(Color(0,255,0))
        
        local start_p, end_p = Vector(Pos1[1], Pos1[2], Pos1[3]):toScreen(), Vector(Pos1[1], Pos1[2], Pos2[3]):toScreen()
        render.drawLine(start_p["x"],start_p["y"],end_p["x"],end_p["y"])
        
        start_p, end_p = Vector(Pos1[1], Pos1[2], Pos2[3]):toScreen(), Vector(Pos1[1], Pos2[2], Pos2[3]):toScreen()
        render.drawLine(start_p["x"],start_p["y"],end_p["x"],end_p["y"])
        
        start_p, end_p = Vector(Pos1[1], Pos1[2], Pos2[3]):toScreen(), Vector(Pos2[1], Pos1[2], Pos2[3]):toScreen()
        render.drawLine(start_p["x"],start_p["y"],end_p["x"],end_p["y"])
        
        start_p, end_p = Vector(Pos2[1], Pos2[2], Pos2[3]):toScreen(), Vector(Pos2[1], Pos2[2], Pos1[3]):toScreen()
        render.drawLine(start_p["x"],start_p["y"],end_p["x"],end_p["y"])
        
        start_p, end_p = Vector(Pos1[1], Pos2[2], Pos2[3]):toScreen(), Vector(Pos2[1], Pos2[2], Pos2[3]):toScreen()
        render.drawLine(start_p["x"],start_p["y"],end_p["x"],end_p["y"])
        
        start_p, end_p = Vector(Pos1[1], Pos2[2], Pos1[3]):toScreen(), Vector(Pos2[1], Pos2[2], Pos1[3]):toScreen()
        render.drawLine(start_p["x"],start_p["y"],end_p["x"],end_p["y"])
        
        start_p, end_p = Vector(Pos1[1], Pos1[2], Pos1[3]):toScreen(), Vector(Pos2[1], Pos1[2], Pos1[3]):toScreen()
        render.drawLine(start_p["x"],start_p["y"],end_p["x"],end_p["y"])
        
        start_p, end_p = Vector(Pos2[1], Pos1[2], Pos1[3]):toScreen(), Vector(Pos2[1], Pos1[2], Pos2[3]):toScreen()
        render.drawLine(start_p["x"],start_p["y"],end_p["x"],end_p["y"])
        
        start_p, end_p = Vector(Pos1[1], Pos1[2], Pos1[3]):toScreen(), Vector(Pos1[1], Pos2[2], Pos1[3]):toScreen()
        render.drawLine(start_p["x"],start_p["y"],end_p["x"],end_p["y"])
        
        start_p, end_p = Vector(Pos1[1], Pos2[2], Pos2[3]):toScreen(), Vector(Pos1[1], Pos2[2], Pos1[3]):toScreen()
        render.drawLine(start_p["x"],start_p["y"],end_p["x"],end_p["y"])
        
        start_p, end_p = Vector(Pos2[1], Pos2[2], Pos1[3]):toScreen(), Vector(Pos2[1], Pos1[2], Pos1[3]):toScreen()
        render.drawLine(start_p["x"],start_p["y"],end_p["x"],end_p["y"])
        
        start_p, end_p = Vector(Pos2[1], Pos2[2], Pos2[3]):toScreen(), Vector(Pos2[1], Pos1[2], Pos2[3]):toScreen()
        render.drawLine(start_p["x"],start_p["y"],end_p["x"],end_p["y"])
    end)
end
